<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√†lisi de dades amb pandas de Python i openair a R</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; position: relative; }
        code { font-family: monospace; }
        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">
<h3>El meu primer codi: Blink</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//El meu primer codi: Blink
void setup() { //Codi que s'executa una vegada i √©s la configuraci√≥.
  pinMode(13, OUTPUT); //Estem dient que el pin 13 √©s una sortida de corrent o OUTPUT on puc 
    // connectar un led.
}

void loop() { //√âs un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una 
    // instrucci√≥ de parada.
 digitalWrite(13, HIGH); // <b>digitalWrite</b> √©s una sortida digital i permet encendre i apagar
    // Nom√©s t√© 2 valors, HIGH i LOW (Enc√®s i apagat)
 delay(500);//√âs el temps en milisegons que ha d'estar, en aquest cas enc√®s.
 digitalWrite(13, LOW);//Aqui <b>digitalWrite</b> fa que s'apagui
 delay(500);
}
    </code></pre>

    </div>

    <div class="content-container">
        <h3>Codi Blink amb un condicional</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Codi Blink amb un condicional
        
int ledPin = 13;
int delayPeriod = 100;
        
void setup() {
    pinMode(ledPin, OUTPUT);
}
        
void loop() {
    digitalWrite(ledPin, HIGH);
    delay(delayPeriod);
    digitalWrite(ledPin, LOW);
    delay(delayPeriod);
    delayPeriod = delayPeriod + 100; //Augmenta el temps 100 milisegons cada vegada
    if (delayPeriod == 1000) { //Quan arriba a 1000 milisegons torna a comen√ßar, aix√≤ significa que quan arriba a 1000 torna a comen√ßar 
        //perqu√® hem posat que el delayPeriod sigui 100 de nou. 
        //Cada vegada √©s m√©s lent perqu√® el temps que triga en encendre i apagar-se √©s major.
        //Si vulgues que cada vegada sigui m√©s r√†pid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de 
        //int delayPeriod = 1000, a final de codi posar el menys a "delayPeriod = delayPeriod - 100", i finalment canviar el condicional per:
        //if (delayPeriod == 100); delayPeriod = 1000;
        //Si vull que el canvi sigui m√©s lent s'hauria de posar un n√∫mero m√©s alt en "delayPeriod = delayPeriod + X"
        //Si vull que el canvi sigui m√©s r√†pid s'hauria de posar un n√∫mero m√©s petit en "delayPeriod = delayPeriod + X"
    delayPeriod = 100;
    }
}
    </code></pre>

    </div>
    <div class="content-container">
        <h3>Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)
            void setup() {
              Serial.begin(9600);//Hem de connectar l'Arduino a la consola s√®rie a 9600 bauds, que s√≥n 9600 s√≠mbols per segon
                //I poden ser aproximadament 9600 bits per segon, per√≤, en alguns casos, necessitem m√©s d'un bit per un s√≠mbol
              int a = 2;
              int b = 2;
              int c = a + b;//Llenguatge arduino accepta les operacions matem√†tiques b√†siques
              Serial.println(c); 
            }
            void loop() {}
            </code></pre>
    </div>
    <div class="content-container">
        <h3>Exemple de temperatura amb operacions matem√†tiques</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Exemple de temperatura amb operacions matem√†tiques
            
            void setup() {
              Serial.begin(9600);
              int degC = 20; //Representa que el sensor ja ha agafat 20 graus i els volem convertir a Fahrenheit
              int degF;
              degF = degC * 9 / 5 + 32;
              Serial.println(degF); //Fes una impressi√≥ a la consola de l'ordinador en una l√≠nea println el valor de la variable fahrenheit.
            }
            void loop(){}
            </code></pre>
    </div>
    <div class="content-container">
        <p>En el seg√ºent codi podem veure com definir unes variables globals i les apliquem moltes vegades repetides
            dins del mateix codi. √âs un codi molt repetitiu.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}
</code></pre>
    </div>
    <div class="content-container">
        <p> Amb el seg√ºent codi, aconseguim el mateix resultat que m√©s amunt, es a dir,
            encendre i apagar 20 vegades amb un delay de 250 milisegons, per√≥ no ho escribim 20
            vegades, si no que fem un cicle for.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 02_08_blik_20_for
        
        int ledPin = 13;
        int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          for (int i = 0; i < 20; i ++) { //Dintre del cicle for, tenim les condicions que ha de complir el cicle
              //que s√≥n des de i = 0 fins a i = 20, ves augmentant un en un. O sigui i++ que es el mateix que i = i + 1
              //Si volgu√©s podria canviar les condicions. fent que els numeros augmentesin diferent
              //(Per exemple i = i + 5)
              
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
          }
         delay(3000);
        }
        </code></pre>
    </div>
    <div class="content-container">
        <p> En el codi anterior, hem dit que repeteixi 20 vegades per√≤ es repeteix infinites vegades perqu√© es repeteix
            20 vegades en un void loop. En el seg√ºent codi, posarem un contador i quan arribi a 20 repeticions s'aturar√†
        </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        // 02_09_blink_20_loop (Aqui es nota perqu√©)
        
        int ledPin = 13;
        int delayPeriod = 100;
        int count = 0;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
         digitalWrite(ledPin, HIGH);
         delay(delayPeriod);
         digitalWrite(ledPin, LOW);
         delay(delayPeriod);
         count ++; //"Count" es una variable global que podria ser local, perqu√® nom√©s afecta al loop.
            //si escric "int count; count ++;" estaria definint una variable local dintre del loop, i no es pot usar en una altre funci√≥ que jo defineixi o
            //al setup
         if (count == 20) { //Quan el comtador arriba a 20 deixa de fer parpadeigs de 100 milisegons i fa una aturada de 3 segons abans de tornar a comen√ßar
           count = 0;
           delay(3000);
         }
        }
         // Dos iguals vol dir que es exactament igual. Si posem 3 iguals "===" es una comparaci√≥ estricta es a dir una comparaci√≥
        // estricta, que compara tamb√© el tipus de variable. Si posem un igual "=" √©s una assignaci√≥ que pot ser temporal o constant
        // si es posa "const" davant es 
        </code></pre>
    </div>
    <div class="content-container">
        <p> El seg√ºent codi es el primer exemple de creaci√≥ d'una funci√≥. Una funci√≥ es com un programa dins dins d'un
            programa.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_01_blink_function
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        // Aquest codi es el principal, anomenat com a "main" en alguns llenguatges. √âs el que s'aplica continuadament. En aquest cas el "void loop()"
        // el loop repeteix 20 vegades el flash.
        // Com cridem una funci√≥?
        // Nom√©s cal posar el nom de la funci√≥ dintre del loop per cridar-la i que s'executi sempre.
        void loop() {
          for (int i = 0; i < 20; i ++) {
            flash();
          }
         delay(3000);
        }
        // per crear una funci√≥ nom√©s cal escriure el nom de la funci√≥ i uns parentesis. Si hagu√©s alguna cosa entre parentesi
        //serian els parametres o arguments de la funci√≥. La paraula "void" en aquest cas es equivalent a la paraula "function" de javascript.
        //triem un nom explicatiu del que fa la funci√≥, i dintre de les claus posem les linees de codi que s'han d'executar quan la cridem pel seu
        //nom dintre del void loop (per exemple). 
        void flash() { 
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
        }
        </code></pre>
    </div>
    <div class="content-container">
        <p>A continuaci√≥ veurem el codi flash per√≤ amb par√†metres. </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_functrion_params
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          flash(20, delayPeriod);
          delay(3000);
        }
        // Podem veure que la funci√≥ te dos par√†metres que son 2 nombres enters i que s'anomenen "numFlashes" i "d"
        // numFlashes no esta definit com a variable global, √©s una variable local definida dins de la funci√≥ "flash"
        // i no te un valor predeterminat, nom√©s ha de complir que sigui un valor enter. El mateix per a la variable "d"
        void flash(int numFlashes, int d) {
            for (int i = 0; i &lt; numFlashes; i++) {
            digitalWrite(ledPin, HIGH);
            delay(d);
            digitalWrite(ledPin, LOW);
            delay(d);
            }
            }

        </code></pre>
    </div>
    
        <div class="content-container">
            <h1>Funcions en Arduino</h1>
            <p>Les funcions d'arduino s√≥n semblants a les funcions que veiem a cinem√†tica directa i inversa. En el cas de la cinem√†tica rob√≤tica 
                utilitzavem funcions Javascript dintre d'un codi HTML. Avans cada funci√≥ com per exemple, calculatePosition () era una funci√≥ 
                sense arguments o par√†metres que estava identificada amb un bloc de codianomenat function i s'executava quan clicavem un bot√≥. 
                Dintre d'aquest bloc hi havien instruccions que permeten fer c√†lculs matem√†tics. En el seg√ºent codi d'arduino, tenim una funcion 
                flash amb dos per√†metres que eren n√∫meros enters anomenat ledPin i de delayPeriod que identifiquen el pin que est√† connectat i el 
                temps que ha d'estar enc√®s o apagat.
            </p>
            <p> Ara farem que un bucle for ss'executi 20 o x vegades dintre d'unbucle for localitzat dintre d'un bucle infinit loop. Ho aconseguim 
                amb la paraula clau static, que fa que una variable s'inicialitzi una vegada que correm el codi  i mai m√©s. La paraula static es deriva 
                del llenguatge C i Arduino √©s un derviat de C++ i Processing, </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_20_faulty

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
            </code></pre>
        </div>

        <div class="content-container">
            <h1>Arrays i Strings</h1>
            <p>Una Array √©s una forma de contenir un llistat de valors, moltes vegades s√≥n valors enters i s'accedeix amb ells per la 
                seva posici√≥, sent la primera posici√≥ [0] del array o element 0. El codi seg√ºent el que fa √©s a la primera linia defineix una 
                array amb 9 valors, i els imprimeix en el monitor s√®rie els seus valors. Ser√† √∫til pel nostre codi morse.
            </p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {

}
            </code></pre>
        </div>
        
        <div class="content-container">
            <p>El codi seg√ºent ja √©s un codi morse, perqu√® combina una array, un bucle for que llegeix l'array i l'aplica a la funci√≥ flash, 
                d'aquesta forma √©s com si escrivis flash(200), flash(200), flash(200), flash(500), flash(500), flash(500), flash(200), flash(200), flash(200).
            </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
        </code></pre>
        </div>

        <div class="content-container">
            <p>Puc crear una funci√≥ que em serveix per quatre lletres i nom√®s quan la crido he de posar el n√∫mero de repeticions com 
                par√†metres o arguments</p>
        </div>

        <div class="content-container">
            <h1>Normes internacionals de codi Morse</h1>
            <ul>
                <li>Una l√≠nia (dash) √©s igual a tres punts</li>
                <li>L'espai entre les parts d'una meteixa lletra √©s igual a un punt (dot). (S = ¬∑¬∑¬∑, l'espai entre cada punt √©s un punt)</li>
                <li>L'espai entre dues lletres de la mateixa paraula s√≥n tres punts (Per exemple entre las S i la O de SOS)</li>
                <li>L'espai entre dues parules √©s igual a set punts (Pa ¬∑¬∑¬∑¬∑¬∑¬∑¬∑ tom√†quet)</li> 
            </ul>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                void eosz (int numFlashes) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(200);
                        digitalWrite(ledPin, LOW);
                        delay(200);
                    }
                }

                void loop(){
                    eosz(1); // Aix√≤ √©s la lletra e
                    eosz(3); // Aix√≤ √©s la lletra s
                    eosz(2); // Aix√≤ √©s la lletra o
                }
            </code></pre>

            <p>Crearem una funci√≥ que ser√† v√†lida pels punts repetits i per les linies repetides amb dos par√†ametres.</p>

            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


                void eosztmo (int numFlashes, int d) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(d);
                        digitalWrite(ledPin, LOW);
                        delay(d);
                    }
                }

                void loop(){
                    eosztmo(1, 600); //Aix√≤ √©s la t
                    eosztmo(3, 600); //Aix√≤ √©s la o
                    eosztmo(3, 200); //Aix√≤ √©s la s
                    eosztmo(1, 200); //Aix√≤ √©s la e
                }
            </code></pre>
        </div>
        <div class="content-container">
        <h1>Codi ASCII</h1>
        <p>L'objectiu del codi seg√ºent √©s entendre que les cadenes o strings s√≥n conjunts de car√†cters ASCII i podem accedir 
            amb ells amb arrays que esta formats per par√®ntesis quadrats i el primer element √©s el 0. En llenguatge C i derivats
            del C com Arduino podem utilitzar punters o pointers que permeten apuntar a un element. En python o JavaScript no hi
            ha punters.</p>
            <p>A continuaci√≥ veuras els caracter ASCII en una taula, que son els utilitzats en els strings o cadenes</p>
            <p>La taula seg√ºent est√† basada en un codi binari de 7 bits, perque 2 elevat a 7 (2^7) es 128, hi hauran desde 0 a 
               127 car√†cters diferents</p>
        <table>
            <thead>
                <tr>
                    <th>ASCII</th>
                    <th>DECIMAL</th>
                    <th>BINARI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>A-Z</td>
                    <td>65-90</td>
                    <td>1000001-1011010</td>
                </tr>
                <tr>
                    <td>a-z</td>
                    <td>97-122</td>
                    <td>1100001-1111010</td>
                </tr>
                <tr>
                    <td>0-9</td>
                    <td>48-57</td>
                    <td>110000-111001</td>
                </tr>
                <tr>
                    <td>espai</td>
                    <td>32</td>
                    <td>100000</td>
                </tr>
            </tbody>
            </th>
        </table>
        <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
            d'intercambiar informaci√≥ amb ordinadors</p>
        <p>UTF8 √©s un sistema Unicode Transformation Format que permet escriure m√©s d'un mili√≥ de car√†cters diferents
            ‚ÄúüôÇ‚Äù U+1F642</p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                // sketch 05-03

                char message[] = "Hello";
                
                void setup() {
                  Serial.begin(9600);
                  message[0] = 'h';
                }
                
                void loop() {
                  Serial.println(message);
                  delay(1000);
                }
            </code></pre>

        </div>
        <div class="content-container">
            <h3>Import√†ncia dels punters + Exemple de codi Morse</h3>
            <p>Hi ha llenguatges amb i sense punters.</p> 
            <ul>
                <li>Exemples de llenguatges amb punters: C i els seus derivats com arduino</li>
                <li>Exemples de llenguatges sense punters: Python i Javascript</li>
            </ul>
            <p>El punter llegeix el contingut d'una adre√ßa de memoria i tambe la posici√≥ de la mateixa adre√ßa i pot manipular-la. Hi ha posicions d'adre√ßes especials, com els sectors d'arrancada.</p>
            <p>El punter serveix per tenir el control total per part del programador de la memoria i els recursos de l'ordinador</p>
            <p>El "Problema" que te es que pot provocar errors a la memoria o accesos no permesos si no saps com fer funcionar correctament el punter</p>
            <p>Els dos s√≠mbols per utilitzar punters son: L'arterisc "*", que serveix per llegir el contingut de l'adre√ßa de memoria. I l'ampersand "&", que llegieix la posici√≥ de l'adre√ßa de memoria</p>
            <p>La memoria de l'ordinador la podem imaginar com caixes d'una llista on cada caixa te un valor unic assignat en hexadecimal que comen√ßa per 0x. Cada caixa te un contingut que pot ser buit (0) o pot contenir un valor</p>
            
            <h4>Operacions avan√ßades amb punters</h4>
            <ul>
                <li><b>Acc√©s directe a la memoria:</b> Permet modificar valors en posicions especifiques.</li>
                <li><b>Manipulaci√≥ eficient d'arrays i strings (cadenes):</b> L'array esencialment es una llista adre√ßes amb principi i final amb un punter al primer element.</li>
                <li><b>Passar grans quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva adre√ßa, estalviant memoria i temps. Aquest es un dels motius per els que C i derivats son mes rapids que python o JS.</li>
                <li><b>Creaci√≥ d'estructures dinamiques:</b> Es pot crear coses com grafics o llistes enlla√ßades de forma facil</li>
                <li><b>Interacci√≥ amb microcontroladors senzilla:</b> Els microcontroladors utilitzen llenguatges de baix nivell (low-level languages) que son mes properes al hardware. Encara que, gracies a l'augment de la memoria, s'han pogut crear llenguatges com micropython o circutpython.</li>
            </ul>
            <h2>Sortides anal√≤giques</h2>
            <p>Algunes sortides d'Arduino i altres microcontroladors s√≥n PWM (pulse with modulation), significa</p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                const int ledPin = 13;

// Al principi del codi, abans de la funci√≥ de configuraci√≥ "setup" i la funci√≥ principal "loop" que s'executa cont√≠nuament hem d'escriure sempre
// variables o constants.
// A m√©s, al principi del codi trobem les constants i variables globals anomenades aix√≠ perqu√® es poden cridar o executar des de qualsevol part del codi, a 
// difer√®ncia de les variables locals que es defineixen i s'utilitzen dintre de la mateixa funci√≥ loop o una unci√≥ addicional.
// Davent de les variables globals haurien d'afegir les biblioteques necess√†ries per fer funcionar el nostre codi, (amb "<i>#include <biblioteca></i>") i l'extensi√≥ 
// "h" deriva de C i significa "biblioteca de headers" o encap√ßalament.

const int dotDelay = 200;

/* Cons

*/

char* letters[] = {
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};

char* numbers[] = {
  "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
    // En el setup o configuraci√≥ del microcontrolador indiquem que el pin 13 que ara es diu "ledPin" sigui √©s una sortida o "Output"
  // Indiquem a l'arduino que es comuniqui amb l'ordinador a traves del port serial o serie i comenci a una velocitat de 
  // 9600 bauds o simbols/segon que s√≥n aprox. 9600 bits/segon.
}

void loop() {
    // El loop √©s el codi principal, i el que el seu nom indica que es repeteix sense parar en un "loop".
  // "char" signica que utilitzem una variable de tipus caracter i l'anomenem "ch".
  // "Serial.available" significa si est√† disponible la comunicaci√≥ serie o "serial monitor" que comunica  el microcontrolador
  // arduino amb el nostre ordinador o dispositiu.
  // La comunicaci√≥ entre arduino i l'ordinador √©s complexa: 
  // Primer pas: l'ordinador envia dades al monitor serie a traves de l'USB per un mecanisme que s'anomena "USB to Serial"
  // Segon pas: la transformaci√≥ anterior d'USB to Serial la fa un xip especial dintre d'Arduino.
  // Tercer pas: les dades en format serie arriben a una part del microcontrolador anomenada UART que significa 
  // "Universal Asynchronous Receiver Transmiter"
  // Quart pas: l'UART envia les dades que rep a una mem√≤ria temporal o "buffer" que pot enmagatzemar 128 bytes fins que s'elimina en
  // el moment que es llegeix -Soy Marticon -by Miguel Angel
  // La funci√≥ serial available retorna el n√∫mero de bytes de dades en el "buffer" que estan esperant per ser llegits. Si no hi ha cap missatge
  // esperant a ser llegit, la funci√≥ retorna a 0
  // La funci√≥ "Serial.read" el que fa √©s llegir el primer o el seg√ºent caracter disponible i l'emmagatzema a la variable "ch"
  // El s√≠mbol >= o <= s'utilitza per comparar amb el n√∫mero d'ASCII que correspon per la lletra "a" per tant, podriem canviar l'a
  // pel n√∫mero 97 i la z √©s el n√∫mero 122.
  // Els altres caracters que podem canviar serien 'A' pel n√∫mero 65, Z pel n√∫mero 90.
  // El caracter '0' correspon al n√∫mero 48 i el caracter '9' correspon al n√∫mero 57.
  // El caracter ' ' correspon al n√∫mero 32.
  // Els condicionals que hi han dintre del condicional general "Serial.avaliable" el que fan √©s dir es que si el caracter √©s 
  // entre la a i la z le restes el valor -a
  // Imaginem que la primera lletra √©s una 'c', que equival al n√∫mero 99, llavors si li restem la 'a' que √©s 97 quedaria un n√∫mero 2.
  // El n√∫mero 2 est√† dintre d'un ([]) √©s a dir, dintre d'una array i correspondria al tercer element de l'array de les lletres.
  // Aquest tercer element √©s "-.-."
  // Un altre exemple seria la 'H' estaria avaluat en un altre condicional, el de les mayuscules, aquest caracter equival 
  // al n√∫mero 72, i li he de restar la 'A' que equival al n√∫mero 65, per tant ch - 'A' √©s 7 que √©s el vuit√© element de l'array
  // de maj√∫scula [7] i letters[7] √©s "...." .
  // Per qu√© s'ha de restar?
  // Per conexier la posici√≥ de la lletra a l'array, perqu√® hem possat l'array ordenat 
  // des de la 'a' fins la 'z' i des de la 'A' fins la 'Z'
  // Ara tenim el n√∫mero per exemple letters[7] igual a "...." i el que volem √©s aplicar una funi√≥.
  char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}
// El "void flashSequence()" √©s una funci√≥ que rep un argument
// El que fa amb aquest argument √©s utilitzar un punter i seguir la seq√ºencia que es troba amb letters[7]
// que √©s "....", aquest quatre caracters o punts s√≥n una seq√ºencia de caracters ordenada gracies al punter*
// El codi seg√ºent el que fa √©s amb la posici√≥ 'i' inicial de 0 que √©s el pointer al principi de l'array "...."
// I el que fa √©s que mentre (While) aquest element 'i' de la seq√ºencia no sigui (!) = NULL, es a dir mentres 
// hi hagi un caracter, crida una funci√≥ diferent anomenada "flashDotOrDash" que rep com a argument el valor de 'i'
// concret en aquella seq√ºencia.
// Despr√©s de rebre'l passa el seg√ºent valor de 'i', si la 'i' era el primer ".", la i++ primera o i = i+1 √©s 
// el segon punt ".". I aix√≠ fins al cinqu√® punt que s'atura tot, perqu√© √©s NULL, es a dir, no hi ha cinqu√® punt.
// El Delay serveix per deixar espai entre lletres o sequences.
void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
}
// La funci√≥ "flashSequence" que llegeix una determinada lletra que rep com a argument, letters[7] i reconeix que 
// est√† formada per "...." i crida la funci√≥ "flashDotOrDash" fins que s'acaben els punts o ratjes i deixa un espai
// al final per indicar que √©s una lletra.
// La funci√≥ "flashDorOrDash" t√© un parametre intern anomenat "dotOrDash". Aquesta funci√≥ sempre encen un led, i sempre
// el deixa un temps enc√©s o delay. En el cas que sigui una ratlla, el fa 3 vegades m√©s llarg que un punt, gracies
// a un condicional "if" o en cas contrari "else". No diem si √©s una ratlla, diem si no √©s un punt
void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
        // El "loop" √©s un bucle i continuament crida a la funci√≥ "flashSequence" que el que fa √©s llegir cada lletra i convertirles
// en punts i ratlles, aquesta funci√≥ crida a la funci√≥ "flashDotOrDash" continuament que fa que s'encenguin els leds segon
// els punts i ratlles. Sempre hem de dividir un codi en diverses funcions, primer per fer-lo m√©s modular i entendre que fa 
// cada funci√≥ i a m√©s ens fa m√©s facil el manteniment i canvis futurs.


<h2>Input i Output: Entrades i sortides</h2>
<p>Les entrades i sortdes poden ser de dues maneres diferents, digitals o anal√≤giques, les digitals poden 
ser de 0 voltso de 3,3 volts i en altres plaques arduino, poden ser 0 volts i 5 volts. Les anal√≤giques
serien graduals, de 0 a 3,3 volts o 5 volts en 2**n pasos, sent "n" el n√∫mero de bits.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int outPin = 3;
// pinMode √©s una funci√≥ predeterminada o "built-in", vol dir que est√† predefinida en el llenguatje
// arduino i sempre ha de rebre 2 argument o parametres, el primer sempre ha de ser un n√∫mer enter o "int"
// (integer) que correspon al n√∫mero de pin que volem conectar (en aquet cas 3), el segon argument √©s el mode
// que pot ser OUTPUT que significa sortida, o INPUT que significa entrada, tamb√© existeix INPUT_PULLUP.
// Posarem un exemple per entendre millor el input 'pullup'. Tenim un ascensor que s'atura a l' inici i al final gracies al
// interruptor del final de cursa (palanca que al arribar al final o principi fa). El pullup per definici√≥  que √©s 
// conecti a una resistencia f√≠sica de entre 20 i 50 kOhms que per defecte est√† en HIGH, al arribar al final en cursa
// es defieix el canvi a LOW. El cas 'pulldown' no existeix com a mode Arduino, per√≤ si existeix el modo input (faria el contrari)
void setup() {
  pinMode(outPin, OUTPUT);
  Serial.begin(9600); //Miguel Angel
  Serial.println("Enter 1 or 0");
}

void loop() {
  if (Serial.available() > 0) {
    char ch = Serial.read();
    if (ch == '1') {
      digitalWrite(outPin, HIGH);
    }
    else if (ch == '0') {
      digitalWrite(outPin, LOW);
    }
  }
            </code></pre>
        </div>
       char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}

void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
}

void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
</code></pre>
<p> Negaci√≥. El signe d'admiraci√≥ "!" significa negar la variable que es posa despr√©s del signe.</p>
<p> Hi ha dos variables inicials, que son constants per definici√≥ del codi. La variable ledPin es el pin el qual conectem
el led, que es 13 normalment. I el pin 5 es un pin on conectem un interruptor per entrada de dades. El pin 5 esta enc√©s per defecte
perque li hem dit que es un input pull-up, significa que l'interruptor deixa pasar la corrent per defecte. Si fos un input nom√©s 
estaria a 0, es a dir, l'interruptor estaria obert. La variable switch open esta al principi amb valor 1 i quan movem el bot√≥, 
l'apaguem perqu√© la variable switchOpen que estava a 1 es transforma a !switchOpen que esta a 0. I si li torno a negar, sortira 1.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13
    void setup() {
     pinMode(ledPin, OUTPUT);
     pinMode(inputPin, INPUT_PULLUP);
    }
    void loop() {
     int switchOpen = digitalRead(inputPin);
     digitalWrite(ledPin, ! switchOpen);
    }
    </code></pre>
<p> Clica a la imatge seg√ºent per veure la simulaci√≥ </p>
<a href = "https://www.tinkercad.com/things/03GGOfy1KXQ-circuit-54-monk" target = "_blank"> <img src = "54.png"> </a>
<p> Toggles. </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;

    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    void loop()  {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
<a href = "Enlace" target = "_blank"> <img src = "Imagen"> </a>

<p>soluci√≥ sense llibreria: Simplement posant un delay de 500 milisengons que aconsegueix que el senyal que era inestable despres de 500 milisengons ja sigui estable perque ha passat prou temps </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
    }
    }
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
 <p>El "contactBounce" podr√≠em traduir-ho com a rebot de contacte, √©s un problema com√∫ a diferents dispositius com per exemple interruptors m√®canics, com reles (interruptor que canvia la posici√≥
 d'una palanca interna mitjan√ßant electromagnestisme), contactes de bateria. Tots aquests elemets tenen en com√∫ que estan fets per metalls elastics, de forma que quan areto un interruptor mecanic
 el metall que calca el circuit rebota diverses vegades sobre el contacte provocant una inestabilitat en la senyal.</p>
    <img src = "Bouncy_Switch.png">
    <p>Els moviments que veiem a dalt poden ser poc importants en un circuit de pot√®ncia que utilita 220 volts moltes vegades no s'aprecien aquests canvis, per√≤ en un circuit de control
    que funciona amb un voltatge de 3.3 volts o 5 volts i qu√® esta dissenyat per entrende i respondre senyals digitals i anal√≤giques pot provocar que entenguin les pujades i baixades
    com un flux de dades</p>
    <p>Com es pot evitar?</p>
    <p> Ho podem evitar per software com veiem m√©s avall amb una biblioteca o per hardware que vol dir modificar fisicament els elements per reduir el rebot. Per exemple, una superficie llisa
    de contacte seria meillor perque donaria menys rebot, si el metall fos menys elastic, rebotaria menys. Antigament els contactes dels interruptors es mullaven en mercuri per evitar el rebot
    Tamb√© es pot afegir un filtre com un condensador per exemple que emmagatzemaria tots els excesos de c√†rrega produits.</p>
    <p>soluci√≥ amb llibreria </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
    }
    }
</code></pre>

    #include <Bounce2.h> // Instal¬∑la i inclou la llibreria< a href = "https://docs.arduino.cc/libraries/bounce2/"> "Bounce2.h"</a> que √©s compatible amb totes les plaques arduino.
        const int inputPin = 5; // Aquest valor √©s costant i correspon al interruptor
        const int ledPin = 13; // Aquest valor √©s constant i correspon al LED
        int ledValue = LOW; // Aquest valor no es constant, √©s un valor enter, que en aquest cas t√© un valor inicial de 0 o LOW.
        Bounce bouncer = Bounce(); 
        // La maj√∫scula de "Bounce" m'indica que es una classe i al costat de la classe poso el nom del objecte que tindra totes les caracteristiques e la classe anterior.
        Per exemple: Homosapiens matr√≠. Bounce(); escrit amb majuscules √©s un metode d'una calsse que s'aplica a l'objecte "bounce". Aquest sistema est√† basat en el llenguatge C++ perqu√® l'autor
        de la biblioteca ho ha descrit aix√≠.
        void setup() {
        pinMode(inputPin, INPUT_PULLUP);
        pinMode(ledPin, OUTPUT);
        bouncer.attach(inputPin); //La sintaxi del punt o dot syntax √©s molt important perqu√® apliquem un m√®tode o un funci√≥ definida a la classe a un objecte concret que √©s bouncer. Aquesta funci√≥
        attach dep√®n nom√©s d'un argument o par√†metre que √©s inputPin. L'attach lliga l'interruptor fisic que est√† en inputPin a l'objecte bouncer que hem de controlar.
        // bouncer.interval(50); // interval in ms
        }

        void loop() {
        if (bouncer.update() && bouncer.read() == LOW) { // Linea clau perque esta comprovant si ha canviat (bouncer.update retona verdader o TRUE si alguna cosa ha canviat al objecte
        bouncer i la segona part de codi comprova si m√©s a m√©s comprova si el bot√≥ (&&) del interruptor est√† apagat, perqu√® est√† obert. Si est√† apagat, el condicional seguent es far√†.
          ledValue = ! ledValue; // Si est√† enc√©s, apaga. Si est√† apagat, enc√©n.
          digitalWrite(ledPin, ledValue);
        }
        }void loop() {
        if (bouncer.update() && bouncer.read() == LOW) {
          ledValue = ! ledValue;
          digitalWrite(ledPin, ledValue);
        // El rebot de contacte (Contact Bounce) esta present en reles (Interruptors que canvia de estat depenent de l'electricitat), interruptors, contactes de bateria. Tots aquests
        // Estan fets per metalls elastics, de forma que quan yo apreto un interruptor mecanic, el metall rebota diverses vegades sobre el contacte, provocant una inestabilitat al
        // contacte
        }
        }
 </code>
</pre>
<p> Algunes sortides d'arduino i altres microcontroladors s√≥n PWM (Pulse Width Modulation). Com podem veure a la imatge de sota, es tracta
de una modulaci√≥ de l'ample del pols. Es a dir, es modula el temps que es 0 o que es 1, aconseguint que en 0 s'apagui i en 1 s'encengui.
Nosaltres no observem que s'encengui o que s'apagui perque es molt rapid el canvi i la nostra visi√≥ no ens permet veure-ho. Nosaltres veiem
la llum en un percentatge que depen del percentatge de temps que ha estat ences la sortida </p>
<img src = "pwm.png">

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Enter Volts 0 to 5");
}

void loop() {
  if (Serial.available() > 0) {
    float volts = Serial.parseFloat();
    int pwmValue = volts * 255.0 / 5.0;
    analogWrite(outputPin, pwmValue);
  }
}
</code></pre>
<p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Despr√©s de definir
el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escrigui a la consola
del programa Arduino IDE: Enter volts 0-5.</p>
<p> Al loop principal comprova que hi hagi car√†cters escrits a la consola, despr√©s agafa el valor que hem 
donat i el guarda en la variable volts. El valor pot ser en decimals perqu√® posa float ("Floating point number").
El m√®tode parseFloat l'apliquem amb la sintaxi del punt al objecte Serial (Que es posa en maj√∫scula, normalment
seria una classe en maj√∫scula) i agafa el valor de la consola s√®rie</p>
<p> La variable pwmValue √©s entera (int o "integer") i el que fa √©s convertir el valor de volts (0-5) a valors
de 0-255, que √©s el numero de bits (2^8=256). Si fos un ESP32-S3 de 14 bits tal com indica el data
sheet o fulla de caracteristiques de el ESP32-S3la linea de codi seria:
"Serial.println("Enter Volts 0-3.3")
"int pwmValue = volts * 16384.0 / 3.3" </p>

<p> El ESP32-S3 te l'avantatge de tenir m√©s resoluci√≥, es a dir,  pot donar 16384 valors diferents entre 0-3,3 volts
Aix√≥ pot que no es noti en un led, per√≥ es nota en un motor, on l'ESP32 permet accedir a m√©s velocitats diferents. Els
motors poden arribar a 16 bits, que es 2^16 o 65536 valors diferents, depenent del tipus de motor, pot ser observat o no
</p>
        <!-- Scripts necessaris -->

        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"></script>

</body>

</html>
